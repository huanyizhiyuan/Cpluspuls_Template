# 算法模板

## 1.树

### HLD

```c++
struct HLD {
    int n;
    vector<int> siz, top, dep, parent, in, out, seq;
    vector<vector<int>> adj;
    int cur;
    
    HLD() {}
    HLD(int n) {
        init(n);
    }
    void init(int n) {
        this->n = n;
        siz.resize(n);
        top.resize(n);
        dep.resize(n);
        parent.resize(n);
        in.resize(n);
        out.resize(n);
        seq.resize(n);
        cur = 0;
        adj.assign(n, {});
    }
    void addEdge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    void work(int root = 0) {
        top[root] = root;
        dep[root] = 0;
        parent[root] = -1;
        dfs1(root);
        dfs2(root);
    }
    void dfs1(int u) {
        if (parent[u] != -1) {
            adj[u].erase(find(adj[u].begin(), adj[u].end(), parent[u]));
        }
        
        siz[u] = 1;
        for (auto &v : adj[u]) {
            parent[v] = u;
            dep[v] = dep[u] + 1;
            dfs1(v);
            siz[u] += siz[v];
            if (siz[v] > siz[adj[u][0]]) {
                swap(v, adj[u][0]);
            }
        }
    }
    void dfs2(int u) {
        in[u] = cur++;
        seq[in[u]] = u;
        for (auto v : adj[u]) {
            top[v] = v == adj[u][0] ? top[u] : v;
            dfs2(v);
        }
        out[u] = cur;
    }
    int lca(int u, int v) {
        while (top[u] != top[v]) {
            if (dep[top[u]] > dep[top[v]]) {
                u = parent[top[u]];
            } else {
                v = parent[top[v]];
            }
        }
        return dep[u] < dep[v] ? u : v;
    }
    
    int dist(int u, int v) {
        return dep[u] + dep[v] - 2 * dep[lca(u, v)];
    }
    
    int jump(int u, int k) {
        if (dep[u] < k) {
            return -1;
        }
        
        int d = dep[u] - k;
        
        while (dep[top[u]] > d) {
            u = parent[top[u]];
        }
        
        return seq[in[u] - dep[u] + d];
    }
    
    bool isAncester(int u, int v) {
        return in[u] <= in[v] && in[v] < out[u];
    }
    
    int rootedParent(int u, int v) {
        swap(u, v);
        if (u == v) {
            return u;
        }
        if (!isAncester(u, v)) {
            return parent[u];
        }
        auto it = upper_bound(adj[u].begin(), adj[u].end(), v, [&](int x, int y) {
            return in[x] < in[y];
        }) - 1;
        return *it;
    }
    
    int rootedSize(int u, int v) {
        if (u == v) {
            return n;
        }
        if (!isAncester(v, u)) {
            return siz[v];
        }
        return n - siz[rootedParent(u, v)];
    }
    
    int rootedLca(int a, int b, int c) {
        return lca(a, b) ^ lca(b, c) ^ lca(c, a);
    }
};
```

### 虚树

```c++
int n, m, son[N], fa[N], siz[N], top[N], dfn[N], rnk[N], stamp, dep[N];
vector<int>adj[N];
void dfs1(int u, int p){
    son[u] = -1;
    siz[u] = 1;
    for (auto v : adj[u]){
        if (v != p){
            dep[v] = dep[u] + 1;
            fa[v] = u;
            dfs1(v, u);
            siz[u] += siz[v];
            if (son[u] == -1 || siz[v] > siz[son[u]]){
                son[u] = v;
            }
        }
    }
}

void dfs2(int u, int root){
    top[u] = root;
    dfn[u] = ++ stamp;
    rnk[stamp] = u;

    if (son[u] == -1){
        return;
    }
    dfs2(son[u], root);
    for (auto v : adj[u]){
        if (v != fa[u] && v != son[u]){
            dfs2(v, v);
        }
    }
}

int lca(int a,int b){
    while (top[a] != top[b]){
        if (dep[top[a]] < dep[top[b]]){
            swap(a, b);
        }
        a = fa[top[a]];
    }
    return dep[a] < dep[b] ? a : b;
}

vector<int>H[N];
vector<int>a;
void build(){
    int n = a.size();
    sort(a.begin(), a.end(), [&](int p1, int p2){return dfn[p1] < dfn[p2];});
    for (int i = 0;i < n - 1;i ++) a.push_back(lca(a[i], a[i + 1]));
    a.push_back(1);
    sort(a.begin(), a.end(), [&](int p1, int p2){return dfn[p1] < dfn[p2];});
    a.erase(unique(a.begin(), a.end()), a.end());
    n = a.size();
    for (int i = 0;i < n - 1;i ++)H[lca(a[i], a[i + 1])].push_back(a[i + 1]);
}
```

### 树哈希

```c++
//有根树
using u64 = unsigned long long;
const u64 mask = std::chrono::steady_clock::now().time_since_epoch().count();
u64 f(u64 x) {
    x ^= mask;
    x ^= x << 13;
    x ^= x >> 7;
    x ^= x << 17;
    x ^= mask;
    return x;
}
    
u64 dfs(int u, int fa) {
    u64 res = 1;
    for (int v : adj[u]) {
        if (v == fa) continue;
        res += f(dfs(v, u));
    }
    return res;
}

//无根树
待补充
```

### 点分治

```c++
	vector<int>ans(m), q(m);
    for (int i = 0;i < m;i ++){
        cin >> q[i];
    }

    i64 root  = 0, Mx = 1e18;
    vector<int>vis(n + 1), siz(n + 1);
    auto get = [&](auto self, int x, int fa, int n) -> void{
        siz[x] = 1;
        int val = 0;
        for (auto [y, w] : adj[x]){
            if (y == fa || vis[y]) continue;
            self(self, y, x, n);
            siz[x] += siz[y];
            val = max(val, siz[y]);
        }
        val = max(val, n - siz[x]);
        if (val < Mx){
            Mx = val;
            root = x;
        }
    };

    auto clac = [&](int x) -> void{
        set<int>pre = {0};
        vector<int>dis(n + 1);
        
        for (auto [y, w] : adj[x]){
            if (vis[y]) continue;
            vector<int>child;
            auto dfs = [&](auto self, int x, int fa)-> void{
                child.push_back(dis[x]);
                for (auto [y, w] : adj[x]){
                    if (y == fa || vis[y]) continue;
                    dis[y] = dis[x] + w;
                    self(self, y, x);
                }
            };
            dis[y] = w;
            dfs(dfs, y, x);

            for (auto it : child){
                for (int i = 0;i < m;i ++){
                    if (q[i] < it || !pre.count(q[i] - it)) continue;
                    ans[i] = 1;
                }
            }
            pre.insert(child.begin(), child.end());
        }
    };

    auto dfz = [&](auto self, int x, int fa) -> void{
        vis[x] = 1;
        clac(x);
        for (auto [y, w] : adj[x]){
            if (y == fa || vis[y]) continue;
            Mx = 1e18;
            get(get, y, x, siz[y]);
            self(self, root, x);
        }
    };

    get(get, 1, 0, n);
    dfz(dfz, root, 0);//求树上有无距离为k
```



## 2.图论

### 差分约束

|    题意    |            转化            |             连边              |
| :--------: | :------------------------: | :---------------------------: |
| x_a-x_b>=c |       x_b-x_a <= -c        |       `add(a, b, -c);`        |
| x_a-x_b<=c |         x_a-x_b<=c         |        `add(b, a, c);`        |
|  x_a=x_b   | x_a-x_b<= 0,x_b - x_a <= 0 | `add(b, a, 0), add(a, b, 0);` |

```c++
auto spfa = [&](int x){
    vector<int>dis(n + 2, 0x3f3f3f3f), vis(n + 2), num(n + 2);
    dis[x] = 0;
    queue<int>q;
    q.push(x);
    vis[x] = 1; 

    while (!q.empty()){
        int u = q.front();
        q.pop();
        vis[u] = 0;;
        for (auto [v, w] : adj[u]){
            if (dis[v] > dis[u] + w){
                dis[v] = dis[u] + w;
                if (!vis[v]){
                    q.push(v);
                    vis[v] = 1;
                    num[v] ++;
                    if (num[v] == n + 1){
                        return false;
                    }
                }
            }
        }
    }
    return true;
};
```

### SCC(强连通分量)

```c++
struct SCC {
    int n;
    vector<vector<int>> adj;
    vector<int> stk;
    vector<int> dfn, low, bel;
    int cur, cnt;
    
    SCC() {}
    SCC(int n) {
        init(n);
    }
    
    void init(int n) {
        this->n = n;
        adj.assign(n, {});
        dfn.assign(n, -1);
        low.resize(n);
        bel.assign(n, -1);
        stk.clear();
        cur = cnt = 0;
    }
    
    void addEdge(int u, int v) {
        adj[u].push_back(v);
    }
    
    void dfs(int x) {
        dfn[x] = low[x] = cur++;
        stk.push_back(x);
        
        for (auto y : adj[x]) {
            if (dfn[y] == -1) {
                dfs(y);
                low[x] = min(low[x], low[y]);
            } else if (bel[y] == -1) {
                low[x] = min(low[x], dfn[y]);
            }
        }
        
        if (dfn[x] == low[x]) {
            int y;
            do {
                y = stk.back();
                bel[y] = cnt;
                stk.pop_back();
            } while (y != x);
            cnt++;
        }
    }
    
    vector<int> work() {
        for (int i = 0; i < n; i++) {
            if (dfn[i] == -1) {
                dfs(i);
            }
        }
        return bel;
    }
};
```

### 点双

```c++
int dfn[N], low[N], p[N], id[N], cnt, tot;
vector<int>dcc[N];
stack<int>s;
void dfs(int u, int root){
    dfn[u] = low[u] = ++ cnt;
    s.push(u);

    if (u == root and !adj[u].size()){
        ++ tot;
        dcc[tot].push_back(u);
        return;
    }

    int flag = 0;
    for (auto v : adj[u]){
        if (!dfn[v]){
            dfs(v, root);
            low[u] = min(low[u], low[v]);
            if (dfn[u] <= low[v]){
                flag ++;
                if (u != root || flag > 1){
                    p[u] = 1;//标记为割点
                }
                int y;
                tot ++;
                do{
                    y = s.top();
                    s.pop();
                    id[y] = tot;
                    dcc[tot].push_back(y);
                }while(y != v);;
                dcc[tot].push_back(u);
            }
        }else{
            low[u] = min(low[u], dfn[v]);
        }
    }
}

//图上不能有重边和自环
for (int i = 1;i <= n;i ++){
    if (!dfn[i]){
        dfs(i, i);
    }
}
```

### 边双

```c++
//无重边情况
int dfn[N], low[N], col[N], cnt, tot;
vector<int>dcc[N];
stack<int>s;
set<array<int, 2>>bridge;
void dfs(int u, int p){
    dfn[u] = low[u] = ++ cnt;
    s.push(u);
    for (auto v : adj[u]){
        if (v == p) continue;
        if (dfn[v] == 0){
            dfs(v, u);
            low[u] = min(low[u], low[v]);
        } else if (col[v] == 0 and dfn[v] < dfn[u]){
            low[u] = min(low[u], dfn[v]);
        }
    }
    if (dfn[u] == low[u]){
        int y;
        tot ++;
        do{
            y = s.top();
            col[y] = tot;
            s.pop(); 
            dcc[tot].push_back(y);
        }while (y != u);
    }
}

//有重边情况
vector<pair<int, int>>adj[N];
int dfn[N], low[N], col[N], cnt, tot;
vector<int>dcc[N];
stack<int>s;
set<array<int, 2>>bridge;
void dfs(int u, int las){
    dfn[u] = low[u] = ++ cnt;
    s.push(u);
    for (auto [v, w] : adj[u]){
        if (w == (las ^ 1)) continue;
        if (dfn[v] == -1){
            dfs(v, w);
            low[u] = min(low[u], low[v]);
        } else{
            low[u] = min(low[u], dfn[v]);
        }
    }
    if (dfn[u] == low[u]){
        tot ++;
        int y;
        do{
            y = s.top();
            s.pop();
            col[y] = tot;
            dcc[tot].push_back(y);
        }while (y != u);
    }
}

for (int i = 0;i <= n;i ++){
    dfn[i] = -1;
}

for (int i = 1;i <= n;i ++){
    if (dfn[i] == -1){
        dfs(i, 0);
    }
}
```

### 2-sat

```c++
//建边后跑边双
    for (int i = 1;i <= n;i ++){
        if (col[i] == col[i + n]){
            cout << "IMPOSSIBLE\n";
            return 0;
        }
    }
    cout << "POSSIBLE\n";
    for (int i = 1;i <= n;i ++){
        if (col[i] > col[i + n]) cout << 1 << " ";
        else cout << 0 << " ";
    }
```

### 三四元环

```c++
//三元环  
	cin >> n >> m;
  for (int i = 1; i <= m; i++) cin >> u[i] >> v[i], deg[u[i]]++, deg[v[i]]++;
  for (int i = 1; i <= m; i++) {
    if ((deg[u[i]] == deg[v[i]] && u[i] > v[i]) || deg[u[i]] < deg[v[i]])
      swap(u[i], v[i]);
    addEdge(u[i], v[i]);
  }
  for (int u = 1; u <= n; u++) {
    for (int i = head[u]; i; i = edge[i].nxt) vis[edge[i].to] = true;
    for (int i = head[u]; i; i = edge[i].nxt) {
      int v = edge[i].to;
      for (int j = head[v]; j; j = edge[j].nxt) {
        int w = edge[j].to;
        if (vis[w]) total++;
      }
    }
    for (int i = head[u]; i; i = edge[i].nxt) vis[edge[i].to] = false;
  }
  cout << total << '\n';

//四元环
  cin >> n >> m;
  for (int i = 1; i <= m; i++) {
    int u, v;
    cin >> u >> v;
    E[u].push_back(v);
    E[v].push_back(u);
    deg[u]++, deg[v]++;
  }
  for (int u = 1; u <= n; u++)
    for (int v : E[u])
      if (deg[u] > deg[v] || (deg[u] == deg[v] && u > v)) E1[u].push_back(v);
  for (int a = 1; a <= n; a++) {
    for (int b : E1[a])
      for (int c : E[b]) {
        if (deg[a] < deg[c] || (deg[a] == deg[c] && a <= c)) continue;
        total += cnt[c]++;
      }
    for (int b : E1[a])
      for (int c : E[b]) cnt[c] = 0;
  }
  cout << total << '\n';
```



### 最大流

```c++
template<class T>
struct MaxFlow {
    struct _Edge {
        int to;
        T cap;
        _Edge(int to, T cap) : to(to), cap(cap) {}
    };
     
    int n;
    vector<_Edge> e;
    vector<vector<int>> g;
    vector<int> cur, h;
     
    MaxFlow() {}
    MaxFlow(int n) {
        init(n);
    }
     
    void init(int n) {
        this->n = n;
        e.clear();
        g.assign(n, {});
        cur.resize(n);
        h.resize(n);
    }
     
    bool bfs(int s, int t) {
        h.assign(n, -1);
        queue<int> que;
        h[s] = 0;
        que.push(s);
        while (!que.empty()) {
            const int u = que.front();
            que.pop();
            for (int i : g[u]) {
                auto [v, c] = e[i];
                if (c > 0 && h[v] == -1) {
                    h[v] = h[u] + 1;
                    if (v == t) {
                        return true;
                    }
                    que.push(v);
                }
            }
        }
        return false;
    }
     
    T dfs(int u, int t, T f) {
        if (u == t) {
            return f;
        }
        auto r = f;
        for (int &i = cur[u]; i < int(g[u].size()); ++i) {
            const int j = g[u][i];
            auto [v, c] = e[j];
            if (c > 0 && h[v] == h[u] + 1) {
                auto a = dfs(v, t, min(r, c));
                e[j].cap -= a;
                e[j ^ 1].cap += a;
                r -= a;
                if (r == 0) {
                    return f;
                }
            }
        }
        return f - r;
    }
    void addEdge(int u, int v, T c) {
        g[u].push_back(e.size());
        e.emplace_back(v, c);
        g[v].push_back(e.size());
        e.emplace_back(u, 0);
    }
    T flow(int s, int t) {
        T ans = 0;
        while (bfs(s, t)) {
            cur.assign(n, 0);
            ans += dfs(s, t, numeric_limits<T>::max());
        }
        return ans;
    }
     
    vector<bool> minCut() {
        vector<bool> c(n);
        for (int i = 0; i < n; i++) {
            c[i] = (h[i] != -1);
        }
        return c;
    }
     
    struct Edge {
        int from;
        int to;
        T cap;
        T flow;
    };
    vector<Edge> edges() {
        vector<Edge> a;
        for (int i = 0; i < e.size(); i += 2) {
            Edge x;
            x.from = e[i + 1].to;
            x.to = e[i].to;
            x.cap = e[i].cap + e[i + 1].cap;
            x.flow = e[i + 1].cap;
            a.push_back(x);
        }
        return a;
    }
};

const int N = 5010, M = 10010, INF = 0x3f3f3f3f;
int n, m, s, t;
int h[N], e[M], f[M], ne[M], idx;
int d[N], cur[N];

void add(int u,int v,int c, int d = 0){
    e[idx] = v, ne[idx] = h[u], f[idx] = c, h[u] = idx ++;
    e[idx] = u, ne[idx] = h[v], f[idx] = d, h[v] = idx ++;
}

bool bfs(){
    queue<int>q;
    memset(d, -1, sizeof d);
    q.push(s);
    d[s] = 0;
    cur[s] = h[s];
    while (!q.empty()){
        auto u = q.front();
        q.pop();
        for (int i = h[u]; ~i; i = ne[i]){
            int v = e[i];
            if (d[v] == -1 and f[i]){
                d[v] = d[u] + 1;
                cur[v] = h[v];
                if (v == t) return true;
                q.push(v);
            }
        }
    }
    return false;
}

int dfs(int u, int limit) {
    if (u == t) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i]) {
        cur[u] = i;
        int j = e[i];
        if (d[j] == d[u] + 1 && f[i]) {
            int t = dfs(j, min(f[i], limit - flow));
            if (!t) d[j] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic() {
    int r = 0, flow;
    while (bfs()) while (flow = dfs(s, INF)) r += flow;
    return r;
}
```

### 费用流

```c++
template<class T>
struct MinCostFlow {
    struct _Edge {
        int to;
        T cap;
        T cost;
        _Edge(int to_, T cap_, T cost_) : to(to_), cap(cap_), cost(cost_) {}
    };
    int n;
    vector<_Edge> e;
    vector<vector<int>> g;
    vector<T> h, dis;
    vector<int> pre;
    bool dijkstra(int s, int t) {
        dis.assign(n, numeric_limits<T>::max());
        pre.assign(n, -1);
        priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> que;
        dis[s] = 0;
        que.emplace(0, s);
        while (!que.empty()) {
            T d = que.top().first;
            int u = que.top().second;
            que.pop();
            if (dis[u] != d) {
                continue;
            }
            for (int i : g[u]) {
                int v = e[i].to;
                T cap = e[i].cap;
                T cost = e[i].cost;
                if (cap > 0 && dis[v] > d + h[u] - h[v] + cost) {
                    dis[v] = d + h[u] - h[v] + cost;
                    pre[v] = i;
                    que.emplace(dis[v], v);
                }
            }
        }
        return dis[t] != numeric_limits<T>::max();
    }
    MinCostFlow() {}
    MinCostFlow(int n_) {
        init(n_);
    }
    void init(int n_) {
        n = n_;
        e.clear();
        g.assign(n, {});
    }
    void addEdge(int u, int v, T cap, T cost) {
        g[u].push_back(e.size());
        e.emplace_back(v, cap, cost);
        g[v].push_back(e.size());
        e.emplace_back(u, 0, -cost);
    }
    pair<T, T> flow(int s, int t) {
        T flow = 0;
        T cost = 0;
        h.assign(n, 0);
        while (dijkstra(s, t)) {
            for (int i = 0; i < n; ++i) {
                h[i] += dis[i];
            }
            T aug = numeric_limits<int>::max();
            for (int i = t; i != s; i = e[pre[i] ^ 1].to) {
                aug = min(aug, e[pre[i]].cap);
            }
            for (int i = t; i != s; i = e[pre[i] ^ 1].to) {
                e[pre[i]].cap -= aug;
                e[pre[i] ^ 1].cap += aug;
            }
            flow += aug;
            cost += aug * h[t];
        }
        return make_pair(flow, cost);
    }
    struct Edge {
        int from;
        int to;
        T cap;
        T cost;
        T flow;
    };
    vector<Edge> edges() {
        vector<Edge> a;
        for (int i = 0; i < e.size(); i += 2) {
            Edge x;
            x.from = e[i + 1].to;
            x.to = e[i].to;
            x.cap = e[i].cap + e[i + 1].cap;
            x.cost = e[i].cost;
            x.flow = e[i + 1].cap;
            a.push_back(x);
        }
        return a;
    }
};
```



## 3.数论

### 质数筛

```c++
vector<int>p, minp, isprime;
void sieve(int n){
    isprime.resize(n + 1, 0);
    minp.resize(n + 1);
    minp[1] = 1;
    for (int i = 2;i <= n;i ++){
        if (!isprime[i]){
            p.push_back(i);
        }
        for (int j = 0;j < p.size() and i * p[j] <= n;j ++){
            minp[i * p[j]] = p[j];
            isprime[i * p[j]] = 1;
            if (i % p[j] == 0){
                break;
            }
        }
    }
}
```

### 组合数

```c++
constexpr int P = 998244353, N = 2e6 + 10;
i64 fac[N], infac[N];
i64 qmi(i64 a,i64 b){
    i64 ans = 1;
    while (b){
        if (b & 1) ans = ans * a % P;
        a = a * a % P;
        b >>= 1;
    }
    return ans;
}
void init(){
    fac[0] = 1;
    for (int i = 1;i < N;i ++){
        fac[i] = fac[i - 1] * i % P;
    }
    infac[N - 1] = qmi(fac[N - 1], P - 2);
    for (int i = N - 2;i >= 0;i --){
        infac[i] = infac[i + 1] * (i + 1) % P;
    }
}

i64 C(int a, int b){
    if (a < 0 || b < 0 || a < b) return 0; 
    return fac[a] * infac[a - b] % P * infac[b] % P;
}
i64 A(int a,int b){
    if (a < 0 || b < 0 || a < b) return 0; 
    return fac[a] * infac[a - b] % P;
}
```

### exgcd

```c++
i64 exgcd(i64 a, i64 b, i64& x, i64& y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    i64 d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;   
}    
```

### excrt

```c++
i64 mul(i64 a, i64 b, i64 p) {
    i64 ans = 0;
    while (b) {
        if (b & 1) ans = (ans + a) % p;
        a = (a + a) % p;
        b >>= 1;
    }
    return ans;
}

i64 exgcd(i64 a, i64 b, i64& x, i64& y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    i64 d = exgcd(b, a % b, y, x);
    y -= (a / b) * x;
    return d;
}

i64 excrt(vector<int>ai, vector<int>bi) {
    i64 M = bi[0], ans = ai[0];
    int n = ai.size();
    for (int i = 1; i < n; i++) {
        i64 a = M, b = bi[i], c = (ai[i] - ans % b + b) % b;
        i64 x, y;
        i64 g = exgcd(a, b, x, y);
        if (c % g != 0) return -1; 
        i64 bg = b / g;
        x = mul(x, c / g, bg);
        ans += x * M;
        M *= bg;
        ans = (ans % M + M) % M;
    }
    return (ans % M + M) % M;
}
```

### BSGS

```c++
struct BSGS{
    i64 a, b, p;
    map<i64, i64>f;

    BSGS(){
    }

    i64 qmi(i64 a,i64 b, i64 p){
        i64 res = 1;
        while (b){
            if (b & 1) res = res * a % p;
            b >>= 1;
            a = a * a % p;
        }
        return res;
    }

    void exgcd(i64 a,i64 b, i64 &x, i64 &y){
        if (!b){
            x = 1, y = 0;
        }else{
            exgcd(b, a % b, x, y);
            i64 t = x;
            x = y;
            y = t - a / b * y;
        }
    }

    i64 inv(i64 a, i64 b){
        i64 x, y;
        exgcd(a, b, x, y);
        return (x % b + b) % b;
    }

    i64 bsgs(i64 a, i64 b, i64 p){
        f.clear();
        i64 m = ceil(sqrt(p));
        b %= p;
        for (int i = 1;i <= m;i ++){
            b = b * a % p;
            f[b] = i;
        }

        i64 tmp = qmi(a, m, p);
        b = 1;

        for (int i = 1;i <= m;i ++){
            b = b * tmp % p;
            if (f.count(b) > 0){
                return (i * m - f[b] + p) % p;
            }
        }
        return -1;
    }

    i64 exbsgs(i64 a, i64 b, i64 p){
        if (b == 1 || p == 1) return 0;
        i64 g = gcd(a, p), k = 0, na = 1;
        while (g > 1){
            if (b % g != 0) return -1;
            k ++;
            b /= g;
            p /= g;
            na = na * (a / g) % p;
            if (na == b) return k;
            g = gcd(a, p);
        }
        i64 f = bsgs(a, b * inv(na, p) % p, p);
        if (f == -1) return -1;
        return f + k;
    }
};
```

### 判素数

```c++
i64 mul(i64 a, i64 b, i64 m) {
    return static_cast<__int128>(a) * b % m;
}
i64 power(i64 a, i64 b, i64 m) {
    i64 res = 1 % m;
    for (; b; b >>= 1, a = mul(a, a, m))
        if (b & 1)
            res = mul(res, a, m);
    return res;
}
bool isprime(i64 n) {
    if (n < 2)
        return false;
    static constexpr int A[] = {2, 3, 5, 7, 11, 13, 17, 19, 23};
    int s = __builtin_ctzll(n - 1);
    i64 d = (n - 1) >> s;
    for (auto a : A) {
        if (a == n)
            return true;
        i64 x = power(a, d, n);
        if (x == 1 || x == n - 1)
            continue;
        bool ok = false;
        for (int i = 0; i < s - 1; ++i) {
            x = mul(x, x, n);
            if (x == n - 1) {
                ok = true;
                break;
            }
        }
        if (!ok)
            return false;
    }
    return true;
}
vector<i64> factorize(i64 n) {
    vector<i64> p;
    function<void(i64)> f = [&](i64 n) {
        if (n <= 10000) {
            for (int i = 2; i * i <= n; ++i)
                for (; n % i == 0; n /= i)
                    p.push_back(i);
            if (n > 1)
                p.push_back(n);
            return;
        }
        if (isprime(n)) {
            p.push_back(n);
            return;
        }
        auto g = [&](i64 x) {
            return (mul(x, x, n) + 1) % n;
        };
        i64 x0 = 2;
        while (true) {
            i64 x = x0;
            i64 y = x0;
            i64 d = 1;
            i64 power = 1, lam = 0;
            i64 v = 1;
            while (d == 1) {
                y = g(y);
                ++lam;
                v = mul(v, abs(x - y), n);
                if (lam % 127 == 0) {
                    d = __gcd(v, n);
                    v = 1;
                }
                if (power == lam) {
                    x = y;
                    power *= 2;
                    lam = 0;
                    d = __gcd(v, n);
                    v = 1;
                }
            }
            if (d != n) {
                f(d);
                f(n / d);
                return;
            }
            ++x0;
        }
    };
    f(n);
    sort(p.begin(), p.end());
    return p;
}
```

## 4.计算几何

```c++
using u32 = uint32_t;
using i64 = int64_t;
using u64 = uint64_t;
using f64 = long double;
using i128 = __int128;
using f128 = __float128;template<class T>

using P = Point<i64>;
using L = Line<i64>;
```

### 点封装

```c++

struct Point {
    T x;
    T y;
    Point(const T &x_ = 0, const T &y_ = 0) : x(x_), y(y_) {}

    template<class U>
    operator Point<U>() {
        return Point<U>(U(x), U(y));
    }
    Point &operator+=(const Point &p) & {
        x += p.x;
        y += p.y;
        return *this;
    }
    Point &operator-=(const Point &p) & {
        x -= p.x;
        y -= p.y;
        return *this;
    }
    Point &operator*=(const T &v) & {
        x *= v;
        y *= v;
        return *this;
    }
    Point &operator/=(const T &v) & {
        x /= v;
        y /= v;
        return *this;
    }
    Point operator-() const {
        return Point(-x, -y);
    }
    constexpr friend Point operator+(Point a, const Point &b) {
        return a += b;
    }
    constexpr friend Point operator-(Point a, const Point &b) {
        return a -= b;
    }
    constexpr friend Point operator*(Point a, const T &b) {
        return a *= b;
    }
    constexpr friend Point operator/(Point a, const T &b) {
        return a /= b;
    }
    constexpr friend Point operator*(const T &a, Point b) {
        return b *= a;
    }
    constexpr friend bool operator==(const Point &a, const Point &b) {
        return a.x == b.x && a.y == b.y;
    }
    friend std::istream &operator>>(std::istream &is, Point &p) {
        return is >> p.x >> p.y;
    }
    friend std::ostream &operator<<(std::ostream &os, const Point &p) {
        return os << "(" << p.x << ", " << p.y << ")";
    }
};
```

### 线封装

```c++
template<class T>
struct Line {
    Point<T> a;
    Point<T> b;
    Line(const Point<T> &a_ = Point<T>(), const Point<T> &b_ = Point<T>()) : a(a_), b(b_) {}
};
```

### 基础点线

```c++
template<class T>
T dot(const Point<T> &a, const Point<T> &b) {
    return a.x * b.x + a.y * b.y;
}

template<class T>
T cross(const Point<T> &a, const Point<T> &b) {
    return a.x * b.y - a.y * b.x;
}

template<class T>
T square(const Point<T> &p) {
    return dot(p, p);
}

template<class T>
f64 length(const Point<T> &p) {
    return sqrtl(square(p));
}

template<class T>
f64 length(const Line<T> &l) {
    return length(l.a - l.b);
}

template<class T>
Point<T> normalize(const Point<T> &p) {
    return p / length(p);
}

template<class T>
bool parallel(const Line<T> &l1, const Line<T> &l2) {
    return cross(l1.b - l1.a, l2.b - l2.a) == 0;
}

template<class T>
f64 distance(const Point<T> &a, const Point<T> &b) {
    return length(a - b);
}

template<class T>
f64 distancePL(const Point<T> &p, const Line<T> &l) {
    return std::abs(cross(l.a - l.b, l.a - p)) / length(l);
}

template<class T>
f64 distancePS(const Point<T> &p, const Line<T> &l) {
    if (dot(p - l.a, l.b - l.a) < 0) {
        return distance(p, l.a);
    }
    if (dot(p - l.b, l.a - l.b) < 0) {
        return distance(p, l.b);
    }
    return distancePL(p, l);
}

template<class T>
Point<T> rotate(const Point<T> &a) {
    return Point(-a.y, a.x);
}

template<class T>
int sgn(const Point<T> &a) {
    return a.y > 0 or (a.y == 0 and a.x > 0) ? 1 : -1;
}

template<class T>
f64 angle(const Point<T>& p) {
    return std::atan2(p.y, p.x);
}

template<class T>
f64 angle(const Line<T>& l) {
    return angle(l.b - l.a);
}

template<class T>
bool pointOnLineLeft(const Point<T> &p, const Line<T> &l) {
    return cross(l.b - l.a, p - l.a) > 0;
}

template<class T>
Point<T> lineIntersection(const Line<T> &l1, const Line<T> &l2) {
    return l1.a + (l1.b - l1.a) * (cross(l2.b - l2.a, l1.a - l2.a) / cross(l2.b - l2.a, l1.a - l1.b));
}

template<class T>
bool pointOnSegment(const Point<T> &p, const Line<T> &l) {
    return cross(p - l.a, l.b - l.a) == 0 and std::min(l.a.x, l.b.x) <= p.x and p.x <= std::max(l.a.x, l.b.x) and std::min(l.a.y, l.b.y) <= p.y and p.y <= std::max(l.a.y, l.b.y);
}

template<class T>
bool pointOnLine(const Point<T> &p, const Line<T> &l) {
    return pointOnSegment(p, l) or pointOnSegment(l.a, Line(p, l.b)) or pointOnSegment(l.b, Line(p, l.a));
}

template<class T>
bool pointInPolygon(const Point<T> &a, const std::vector<Point<T>> &p) {
    int n = p.size();
    for (int i = 0; i < n; i++) {
        if (pointOnSegment(a, Line(p[i], p[(i + 1) % n]))) {
            return true;
        }
    }
    int t = 0;
    for (int i = 0; i < n; i++) {
        const auto &u = p[i];
        const auto &v = p[(i + 1) % n];
        if (u.x < a.x and v.x >= a.x and pointOnLineLeft(a, Line(v, u))) {
            t ^= 1;
        }
        if (u.x >= a.x and v.x < a.x and pointOnLineLeft(a, Line(u, v))) {
            t ^= 1;
        }
    }
    return t == 1;
}
```

### 线段相交

```c++
//0: 两条线段不相交。
//1: 两条线段严格相交（交于一点，但不在端点）。
//2: 两条线段重叠（有部分重叠的区域）。
//3: 两条线段在一个端点相交。
template<class T>
std::tuple<int, Point<T>, Point<T>> segmentIntersection(const Line<T> &l1, const Line<T> &l2) {
    if (std::max(l1.a.x, l1.b.x) < std::min(l2.a.x, l2.b.x)) {
        return {0, Point<T>(), Point<T>()};
    }
    if (std::min(l1.a.x, l1.b.x) > std::max(l2.a.x, l2.b.x)) {
        return {0, Point<T>(), Point<T>()};
    }
    if (std::max(l1.a.y, l1.b.y) < std::min(l2.a.y, l2.b.y)) {
        return {0, Point<T>(), Point<T>()};
    }
    if (std::min(l1.a.y, l1.b.y) > std::max(l2.a.y, l2.b.y)) {
        return {0, Point<T>(), Point<T>()};
    }
    if (cross(l1.b - l1.a, l2.b - l2.a) == 0) {
        if (cross(l1.b - l1.a, l2.a - l1.a) != 0) {
            return {0, Point<T>(), Point<T>()};
        } else {
            const auto &maxx1 = std::max(l1.a.x, l1.b.x);
            const auto &minx1 = std::min(l1.a.x, l1.b.x);
            const auto &maxy1 = std::max(l1.a.y, l1.b.y);
            const auto &miny1 = std::min(l1.a.y, l1.b.y);
            const auto &maxx2 = std::max(l2.a.x, l2.b.x);
            const auto &minx2 = std::min(l2.a.x, l2.b.x);
            const auto &maxy2 = std::max(l2.a.y, l2.b.y);
            const auto &miny2 = std::min(l2.a.y, l2.b.y);
            Point<T> p1(std::max(minx1, minx2), std::max(miny1, miny2));
            Point<T> p2(std::min(maxx1, maxx2), std::min(maxy1, maxy2));
            if (!pointOnSegment(p1, l1)) {
                std::swap(p1.y, p2.y);
            }
            if (p1 == p2) {
                return {3, p1, p2};
            } else {
                return {2, p1, p2};
            }
        }
    }
    const auto &cp1 = cross(l2.a - l1.a, l2.b - l1.a);
    const auto &cp2 = cross(l2.a - l1.b, l2.b - l1.b);
    const auto &cp3 = cross(l1.a - l2.a, l1.b - l2.a);
    const auto &cp4 = cross(l1.a - l2.b, l1.b - l2.b);
    if ((cp1 > 0 and cp2 > 0) or (cp1 < 0 and cp2 < 0) or (cp3 > 0 and cp4 > 0) or (cp3 < 0 and cp4 < 0)) {
        return {0, Point<T>(), Point<T>()};
    }
    Point p = lineIntersection(l1, l2);
    if (cp1 != 0 and cp2 != 0 and cp3 != 0 and cp4 != 0) {
        return {1, p, p};
    } else {
        return {3, p, p};
    }
}
```

### 两线段最小距离

```c++
template<class T>
f64 distanceSS(const Line<T> &l1, const Line<T> &l2) {
    if (std::get<0>(segmentIntersection(l1, l2)) != 0) {
        return 0.0;
    }
    return std::min({distancePS(l1.a, l2), distancePS(l1.b, l2), distancePS(l2.a, l1), distancePS(l2.b, l1)});
}
```

### 线段是否完全在多边形里

```c++
template<class T>
bool segmentInPolygon(const Line<T> &l, const std::vector<Point<T>> &p) {
    int n = p.size();
    if (!pointInPolygon(l.a, p)) {
        return false;
    }
    if (!pointInPolygon(l.b, p)) {
        return false;
    }
    for (int i = 0; i < n; i++) {
        const auto &u = p[i];
        const auto &v = p[(i + 1) % n];
        const auto &w = p[(i + 2) % n];
        const auto &[t, p1, p2] = segmentIntersection(l, Line(u, v));

        if (t == 1) {
            return false;
        }
        if (t == 0) {
            continue;
        }
        if (t == 2) {
            if (pointOnSegment(v, l) and v != l.a and v != l.b) {
                if (cross(v - u, w - v) > 0) {
                    return false;
                }
            }
        } else {
            if (p1 != u and p1 != v) {
                if (pointOnLineLeft(l.a, Line(v, u)) or pointOnLineLeft(l.b, Line(v, u))) {
                    return false;
                }
            } else if (p1 == v) {
                if (l.a == v) {
                    if (pointOnLineLeft(u, l)) {
                        if (pointOnLineLeft(w, l) and pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    } else {
                        if (pointOnLineLeft(w, l) or pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    }
                } else if (l.b == v) {
                    if (pointOnLineLeft(u, Line(l.b, l.a))) {
                        if (pointOnLineLeft(w, Line(l.b, l.a)) and pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    } else {
                        if (pointOnLineLeft(w, Line(l.b, l.a)) or pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    }
                } else {
                    if (pointOnLineLeft(u, l)) {
                        if (pointOnLineLeft(w, Line(l.b, l.a)) or pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    } else {
                        if (pointOnLineLeft(w, l) or pointOnLineLeft(w, Line(u, v))) {
                            return false;
                        }
                    }
                }
            }
        }
    }
    return true;
}
```

### 计算一组线段的凸包

```c++

template<class T>
std::vector<Point<T>> hp(std::vector<Line<T>> lines) {
    std::sort(lines.begin(), lines.end(), [&](const auto & l1, const auto & l2) {
        const auto &d1 = l1.b - l1.a;
        const auto &d2 = l2.b - l2.a;
        if (sgn(d1) != sgn(d2)) {
            return sgn(d1) == 1;
        }
        return cross(d1, d2) > 0;
    });
    std::deque<Line<T>> ls;
    std::deque<Point<T>> ps;
    for (const auto &l : lines) {
        if (ls.empty()) {
            ls.push_back(l);
            continue;
        }
        while (!ps.empty() and !pointOnLineLeft(ps.back(), l)) {
            ps.pop_back();
            ls.pop_back();
        }
        while (!ps.empty() and !pointOnLineLeft(ps[0], l)) {
            ps.pop_front();
            ls.pop_front();
        }
        if (cross(l.b - l.a, ls.back().b - ls.back().a) == 0) {
            if (dot(l.b - l.a, ls.back().b - ls.back().a) > 0) {

                if (!pointOnLineLeft(ls.back().a, l)) {
                    assert(ls.size() == 1);
                    ls[0] = l;
                }
                continue;
            }
            return {};
        }
        ps.push_back(lineIntersection(ls.back(), l));
        ls.push_back(l);
    }
    while (!ps.empty() and !pointOnLineLeft(ps.back(), ls[0])) {
        ps.pop_back();
        ls.pop_back();
    }
    if (ls.size() <= 2) {
        return {};
    }
    ps.push_back(lineIntersection(ls[0], ls.back()));
    return std::vector(ps.begin(), ps.end());
}
```

### 凸包面积

```c++
template<class T>
T PolygonArea(const std::vector<Point<T>> &p) {
    T res = T(0);
    int n = p.size();
    for (int i = 0; i < n; i += 1) {
        res += cross(p[i], p[(i + 1) % n]);
    }
    return std::abs(res) * 0.5;
}

```

### 凸包

```c++
template<class T>
std::vector<Point<T>> getHull(std::vector<Point<T>> p) {
    std::vector<Point<T>>h, l;
    std::sort(p.begin(), p.end(), [&](const auto & a, const auto & b) {
        return a.x == b.x ? a.y < b.y : a.x < b.x;
    });
    p.erase(std::unique(p.begin(), p.end()), p.end());
    if (p.size() <= 1) {
        return p;
    }
    for (const auto & a : p) {
        while ((int)h.size() > 1 and cross(a - h.back(), a - h[(int)h.size() - 2]) <= 0) {
            h.pop_back();
        }
        while ((int)l.size() > 1 and cross(a - l.back(), a - l[(int)l.size() - 2]) >= 0) {
            l.pop_back();
        }
        l.push_back(a);
        h.push_back(a);
    }
    l.pop_back();
    std::reverse(h.begin(), h.end());
    h.pop_back();
    l.insert(l.end(), h.begin(), h.end());
    return l;
}
```

### 点对最远距离

```c++
template<class T>
std::tuple<T, Point<T>, Point<T>> getLongest(const std::vector<Point<T>>& ret) {
    std::vector<Point<T>> p = getHull(ret);
    int n = p.size();

    T res = T(0);
    Point<T> a = Point<T>(), b = Point<T>();
    int x = 0, y = 0;
    for (int i = 0; i < n; i += 1) {
        if (p[i].y < p[x].y)x = i;
        if (p[i].y > p[y].y)y = i;
    }
    res = square(p[x] - p[y]);
    a = p[x], b = p[y];
    int i = x, j = y;
    do {
        if (cross(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[j]) < 0) {
            i = (i + 1) % n;
        } else {
            j = (j + 1) % n;
        }
        if (square(p[i] - p[j]) > res) {
            res = square(p[i] - p[j]);
            a = p[i], b = p[j];
        }
    } while (i != x or j != y);
    return {res, a, b};
}
```

### 点对最近距离

```c++

template<class T>
std::tuple<T, Point<T>, Point<T>> getClostest(std::vector<Point<T>> p) {
    std::sort(p.begin(), p.end(), [&](const auto & a, const auto & b) {
        return a.x == b.x ? a.y < b.y : a.x < b.x;
    });
    T res = std::numeric_limits<T>::max();
    Point<T> a = Point<T>(), b = Point<T>();
    int n = p.size();

    auto update = [&](const Point<T>& u, const Point<T>& v) {
        if (res > square(u - v)) {
            res = square(u - v);
            a = u;
            b = v;
        }
    };

    auto s = std::multiset < Point<T>, decltype([](const Point<T>& u, const Point<T>& v) {
        return u.y == v.y ? u.x < v.x : u.y < v.y;
    }) > ();
    std::vector<typename decltype(s)::const_iterator>its(n);
    for (int i = 0, f = 0; i < n; i += 1) {
        while (f < i and (p[i] - p[f]).x * (p[i] - p[f]).x >= res) {
            s.erase(its[f++]);
        }
        auto u = s.upper_bound(p[i]); {
            auto t = u;
            while (true) {
                if (t == s.begin()) {
                    break;
                }
                t = std::prev(t);
                update(*t, p[i]);
                if ((p[i] - *t).y * (p[i] - *t).y >= res) {
                    break;
                }
            }
        }{
            auto t = u;
            while (true) {
                if (t == s.end()) {
                    break;
                }
                if ((p[i] - *t).y * (p[i] - *t).y >= res) {
                    break;
                }
                update(*t, p[i]);
                t = std::next(t);
            }
        }
        its[i] = s.emplace_hint(u, p[i]);
    }

    return {res, a, b};
}
```

### 多边形最小覆盖矩形的面积和顶点

```c++
template<class T>
std::pair<T, std::vector<Point<T>>> rectCoverage(const std::vector<Point<T>>& p) {
    T res = std::numeric_limits<T>::max();
    std::vector<Point<T>>rect;
    std::array<int, 4>pos {};
    int n = p.size();
    if (n < 3) {
        return std::pair(res, rect);
    }
    for (int i = 0, r = 1, j = 1, q = 0; i < n; i += 1) {
        while (cross(p[(i + 1) % n] - p[i], p[(r + 1) % n] - p[i]) >= cross(p[(i + 1) % n] - p[i], p[r] - p[i])) {
            r = (r + 1) % n;
        }
        while (dot(p[(i + 1) % n] - p[i], p[(j + 1) % n] - p[i]) >= dot(p[(i + 1) % n] - p[i], p[j] - p[i])) {
            j = (j + 1) % n;
        }
        if (i == 0) {
            q = j;
        }
        while (dot(p[(i + 1) % n] - p[i], p[(q + 1) % n] - p[i]) <= dot(p[(i + 1) % n] - p[i], p[q] - p[i])) {
            q = (q + 1) % n;
        }
        T d = square(p[i] - p[(i + 1) % n]);
        T area = cross(p[(i + 1) % n] - p[i], p[r] - p[i]) * (dot(p[(i + 1) % n] - p[i], p[j] - p[i]) - dot(p[(i + 1) % n] - p[i], p[q] - p[i])) / d;
        if (area < res) {
            res = area;
            pos[0] = r;
            pos[1] = j;
            pos[2] = q;
            pos[3] = i;
        }
    }
    const auto& [r, j, q, i] = pos;
    Line<T> l1 = Line(p[i], p[(i + 1) % n]);
    Point t = p[(i + 1) % n] - p[i];
    Line<T> l2 = Line(p[r], p[r] + t);
    t = rotate(t);
    Line<T> l3 = Line(p[j], p[j] + t);
    Line<T> l4 = Line(p[q], p[q] + t);

    rect.push_back(lineIntersection(l1, l3));
    rect.push_back(lineIntersection(l1, l4));
    rect.push_back(lineIntersection(l2, l3));
    rect.push_back(lineIntersection(l2, l4));

    rect = getHull(rect);
    return std::pair(res, rect);
}
```

### 计算三角形的重心

```c++
template<class T>
Point<T> triangleHeart(const Point<T>& A, const Point<T>& B, const Point<T>& C) {
    return (A * square(B - C) + B * square(C - A) + C * square(A - B)) / (square(B - C) + square(C - A) + square(A - B));
}

```

### 计算三角形的外心

```c++
template<class T>
Point<T> circumcenter(const Point<T>& a, const Point<T>& b, const Point<T>& c) {
    T D = 2 * (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));
    assert(D != 0);
    Point<T> p;
    p.x = ((square(a) * (b.y - c.y) + (square(b) * (c.y - a.y)) + (square(c) * (a.y - b.y)))) / D;
    p.y = ((square(a) * (c.x - b.x) + (square(b) * (a.x - c.x)) + (square(c) * (b.x - a.x)))) / D;
    return p;
}
```

### 最小圆覆盖（找到覆盖所有的最小圆，返回圆心和半径）

```c++
std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());

template<class T>
std::pair<Point<T>, T> cirlCoverage(std::vector<Point<T>> p) {
    for (int t = 0; t < 7; t += 1) {
        std::shuffle(p.begin(), p.end(), rng);
    }
    int n = p.size();
    Point<T> o = p[0];
    T r = T(0);
    for (int i = 1; i < n; i += 1) {
        if (length(o - p[i]) > r) {
            o = p[i];
            r = T(0);
            for (int j = 0; j < i; j += 1) {
                if (length(o - p[j]) > r) {
                    o = (p[i] + p[j]) / T(2);
                    r = length(o - p[i]);
                    for (int k = 0; k < j; k += 1) {
                        if (length(o - p[k]) > r) {
                            o = circumcenter(p[i], p[j], p[k]);
                            r = length(o - p[i]);
                        }
                    }
                }
            }
        }
    }
    return std::pair(o, r);
}
```

## 5.多项式



## 6.数据结构

### 并查集

```c++
struct DSU {
	vector<int> f, siz;

	DSU() {}
	DSU(int n) {
		init(n);
	}

	void init(int n) {
		f.resize(n);
		iota(f.begin(), f.end(), 0);
		siz.assign(n, 1);
	}

	int find(int x) {
		while (x != f[x]) {
			x = f[x] = f[f[x]];
		}
		return x;
	}

	bool same(int x, int y) {
		return find(x) == find(y);
	}

	bool merge(int x, int y) {
		x = find(x);
		y = find(y);
		if (x == y) {
			return false;
		}
		siz[x] += siz[y];
		f[y] = x;
		return true;
	}

	int size(int x) {
		return siz[find(x)];
	}
};
```

### st表

```c++
template <class T>
struct ST {
    int n, L;
    vector<vector<T>> f;
    ST() {}
    void init(int n_, vector<T> a) {
        n = n_;
        L = __lg(n) + 1;
        f.resize(__lg(n) + 2);
        for (int j = 0; j < L; j++) f[j].resize(n + 2);
        for (int i = 1; i <= n; i++) f[0][i] = a[i - 1];
        for (int j = 1; j < L; j++)
            for (int i = 1; i + (1 << j) - 1 <= n; i++)
                f[j][i] = max(f[j - 1][i], f[j - 1][i + (1 << (j - 1))]);
    }
    void add(int pos, T v) {
        f[0][pos] = v;
        for (int j = 1; j < L; j++) {
            int i = pos - (1 << j) + 1;
            if (i >= 1) f[j][i] = max(f[j - 1][i], f[j - 1][i + (1 << (j - 1))]);
        }
    }
    T get(int l, int r) {
        if (l > r) swap(l, r);
        int len = __lg(r - l + 1);
        return max(f[len][l], f[len][r - (1 << len) + 1]);
    }
};
```

### 树状数组

```c++
template<typename T> 
struct Fenwick {
    vector<T> tr;
    int n;
    T sum;
     
    int lowbit(int x) {
        return x & -x;
    }
     
    Fenwick(int n) : n(n), sum(0) {
        tr.resize(n + 1);
    }
     
    void add(int x, T v) {
        sum += v;
        for (; x <= n; x += lowbit(x))
            tr[x] += v;
    }
     
    T ask(int x) {
        T res = 0;
        for (; x; x -= lowbit(x))
            res += tr[x];
        return res;
    }
     
    void clear() {
        sum = 0;
        fill(tr.begin(), tr.end(), 0);
    }
};

//区间加区间求和树状数组
struct BIT {
    i64 a[N], b[N];

    void add(i64 p, int v) {
        for (int i = p; i < N; i += i & -i) {
            a[i] += v;      
            b[i] += p * v;    
        }
    }

    i64 qry(i64 p) {
        i64 res = 0;
        for (int i = p; i; i &= i - 1) {
            res += (p + 1) * a[i] - b[i]; // 计算前缀和
        }
        return res;
    }

    void add(int l, int r, int v) {
        add(l, v);
        add(r + 1, -v);
    }

    i64 qry(int l, int r) {
        return qry(r) - qry(l - 1);
    }
}bit;
```

### 线段树(无懒标记)

```c++
struct Node{
    int l, r;
    Info info;
}tr[N << 2];
 
void build(int u,int l,int r){
    tr[u] = {l, r};
    if (l == r){
        tr[u].info = Info(a[l]);
        return;
    }
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
    tr[u].info = tr[u << 1].info + tr[u << 1 | 1].info;
}
 
void modify(int u,int x){
    if (tr[u].l == tr[u].r){
        tr[u].info = Info(a[x]);
        return;
    }
    int mid = tr[u].l + tr[u].r >> 1;
    if (x <= mid) modify(u << 1, x);
    else modify(u << 1 | 1, x);
    tr[u].info = tr[u << 1].info + tr[u << 1 | 1].info;  
}
 
Info query(int u,int l,int r){
    if (tr[u].l >= l and tr[u].r <= r){
        return tr[u].info;
    }
    int mid = tr[u].l + tr[u].r >> 1;
    if (r <= mid) return query(u << 1, l, r);
    if (l > mid) return query(u << 1 | 1, l, r);
    return query(u << 1, l, r) + query(u << 1 | 1, l, r);
}
```

### 主席树

```c++
constexpr int N = 2e5 + 10;
int n, m, a[N], idx, root[N];
vector<int>adj[N];
vector<int>nums;

struct Node{
    int l, r, cnt;
}tr[N * 40];

int find(int x){
    return lower_bound(nums.begin(), nums.end(), x) - nums.begin();
}
int build(int l,int r){
    int q = ++ idx;
    if (l == r){
        return q;
    }
    int mid = l + r >> 1;
    tr[q].l = build(l, mid);
    tr[q].r = build(mid + 1, r);
    return q;
}

int insert(int p, int l, int r, int x){
    int q = ++ idx;
    tr[q] = tr[p];
    if (l == r){
        tr[q].cnt ++;
        return q;
    }
    int mid = l + r >> 1;
    if (x <= mid){
        tr[q].l = insert(tr[q].l, l, mid, x);
    }else{
        tr[q].r = insert(tr[q].r, mid + 1, r, x);
    }
    tr[q].cnt = tr[tr[q].l].cnt + tr[tr[q].r].cnt;
    return q;
}

int query(int q, int p, int l, int r, int k){
    if(l == r){
        return l;
    }
    int cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt;
    int mid = l + r >> 1;
    if (k <= cnt){
        return query(tr[q].l, tr[p].l, l, mid, k);
    }else{
        return query(tr[q].r, tr[p].r, mid + 1, r, k - cnt);
    }
}
int main(){
    root[0] = build(0, nums.size() - 1);
    for (int i = 1;i <= n;i ++ ){
        root[i] = insert(root[i - 1], 0, nums.size() - 1, find(a[i]));
    }
}
```

### 线性基

```c++
struct Base{
    i64 a[63] = {}, tmp[63] = {};
    bool flag = false;
    Base(){}
    void insert(i64 x){
        for (int i = 62;i >= 0;i --){
            if (x >> i & 1){
                if (!a[i]){
                    a[i] = x;
                    return;
                }else{
                    x ^= a[i];
                }
            }
        }
        flag = true;
    }
    bool check(i64 x){
        for (int i = 62;i >= 0;i --){
            if (x >> i & 1){
                if (!a[i]){
                    return false;
                }else{
                    x ^= a[i];
                }
            }
        }
        return true;
    }

    i64 qmax(){
        i64 ans = 0;
        for (int i = 62;i >= 0;i --){
            ans = max(ans, ans ^ a[i]);
        }
        return ans;
    }
    i64 qmin(){
        if (flag) return 0;
        for (int i = 0;i <= 62;i ++){
            if (a[i]){
                return a[i];
            }
        }
    }
    i64 query(i64 k){//查询k小值
        i64 ans = 0;
        int cnt = 0;
        k -= flag;
        if (!k) return 0;
        for (int i = 0;i <= 62;i ++){
            for (int j = i - 1;j >= 0;j --){
                if (a[i] >> j & 1){
                    a[i] ^= a[j];
                }
            }
            if (a[i]){
                tmp[cnt ++] = a[i];
            }
        }
        if (k >= (1LL << cnt)) return -1;
        for (int i = 0;i < cnt;i ++){
            if (k >> i & 1){
                ans ^= tmp[i];
            }
        }
        return ans;
    }
};
```



## 7.字符串

### kmp Z-函数

```c++
// nxt[i]为S[:i]的最长 Border， vis[i]=1则匹配
vector<int> kmp(string s, string t) {
    int n = s.size(), m = t.size();

    vector<int> nxt(m + 1);
    s = "-" + s;
    t = "-" + t;

    for (int i = 2, j = 0; i <= m; i++) {
        while (j && t[i] != t[j + 1]) j = nxt[j];
        if (t[i] == t[j + 1]) j++;
        nxt[i] = j;
    }
    vector<int>vis(n + 1);
    for (int i = 1, j = 0; i <= n; i++) {
        while (j && s[i] != t[j + 1]) j = nxt[j];
        if (s[i] == t[j + 1]) j++;
        if (j == m) {
            vis[i - m + 1] ++;
            j = nxt[j];
        }
    }
    return vis;
}
// z[i]表示 s 和 s[i,n−1]的最长公共前缀（LCP）的长度。z[0]=0
vector<int> z_function(string s) {
    int n = (int)s.length();
    vector<int> z(n);
    for (int i = 1, l = 0, r = 0; i < n; ++i) {
        if (i <= r && z[i - l] < r - i + 1) {
            z[i] = z[i - l];
        }else{
            z[i] = max(0, r - i + 1);
            while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];
        }
        if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;
    }
    return z;
}
```

### 字符串哈希

```c++
struct Hash {
    vector<i64> p, h, uh;
    const i64 P = 131;
    const i64 mod = 1e9 + 9;
    Hash(){
    }
    void init(string& s) {
        int n = s.size();
        p.resize(n + 2);
        h.resize(n + 2);
        uh.resize(n + 2);
        p[0] = 1;

        for (int i = 0; i < n; i++) {
            p[i + 1] = p[i] * P % mod;
            h[i + 1] = (h[i] * P % mod + s[i]) % mod;
        }
        
        for (int i = n - 1; i >= 0; i--) {
            uh[i + 1] = (uh[i + 2] * P % mod + s[i]) % mod;
        }
    }
    i64 getL(int l, int r) {
        return (h[r] - h[l - 1] * p[r - l + 1] % mod + mod) % mod;
    }
    i64 getR(int l, int r) {
        return (uh[l] - uh[r + 1] * p[r - l + 1] % mod + mod) % mod;
    }
    bool check(int l, int r, int len) {//反转l到r后字符串是否回文
        i64 dex = (h[len] - getL(l, r) * p[len - r] % mod + getR(l, r) * p[len - r] % mod + mod) % mod;
        i64 dey = (uh[1] - getR(l, r) * p[l - 1] % mod + getL(l, r) * p[l - 1] % mod + mod) % mod;
        return dex == dey;
    }
};
/*
const i64 P1 = 9527;
const i64 mod1 = 1e9 + 9;
const i64 P2 = 3960; 
const i64 mod2 = 998244353; 
*/
```

###  字典树

```c++
constexpr int N = 1e6 + 10;
int cnt[N], tr[N][26], tot = 1;

void insert(string s){
    int p = 1;
    for (auto c : s){
        int &q = tr[p][c - 'a'];
        if (!q){
            q = ++ tot;
        }
        p = q;
    }
    cnt[p] ++;
}

int query(string s){
    int p = 1;
    for (auto c : s){
        int &q = tr[p][c - 'a'];
        if (!q) return 0;
        p = q;
    }
    return cnt[p];
}
```

### AC自动机

```c++
struct AhoCorasick {
    static constexpr int ALPHABET = 26;
    struct Node {
        int len;
        int link;
        array<int, ALPHABET> next;
        Node() : len{0}, link{0}, next{} {}
    };
    
    vector<Node> t;
    
    AhoCorasick() {
        init();
    }
    
    void init() {
        t.assign(2, Node());
        t[0].next.fill(1);
        t[0].len = -1;
    }
    
    int newNode() {
        t.emplace_back();
        return t.size() - 1;
    }
    
    int add(const string &a) {
        int p = 1;
        for (auto c : a) {
            int x = c - 'a';
            if (t[p].next[x] == 0) {
                t[p].next[x] = newNode();
                t[t[p].next[x]].len = t[p].len + 1;
            }
            p = t[p].next[x];
        }
        return p;
    }
    
    void work() {
        queue<int> q;
        q.push(1);
        
        while (!q.empty()) {
            int x = q.front();
            q.pop();
            
            for (int i = 0; i < ALPHABET; i++) {
                if (t[x].next[i] == 0) {
                    t[x].next[i] = t[t[x].link].next[i];
                } else {
                    t[t[x].next[i]].link = t[t[x].link].next[i];
                    q.push(t[x].next[i]);
                }
            }
        }
    }
    
    int next(int p, int x) {
        return t[p].next[x];
    }
    
    int link(int p) {
        return t[p].link;
    }
    
    int len(int p) {
        return t[p].len;
    }
    
    int size() {
        return t.size();
    }
};

int n;
cin >> n;
AhoCorasick ac;
vector<int>end(n);
vector<string>t(n);
for (int i = 0;i < n;i ++){
    cin >> t[i];
    end[i] = ac.add(t[i]);
}
ac.work();

string s;
cin >> s;

int p = 1;
vector<int>f(ac.size());
for (auto c : s){
    p = ac.next(p, c - 'a');
    f[p] ++;
}

vector<vector<int>>adj(ac.size());
for (int i = 2;i < ac.size();i ++){
    adj[ac.link(i)].push_back(i);
}

auto dfs = [&](auto self, int u) -> void{
    for (auto v : adj[u]){
        self(self, v);
        f[u] += f[v];
    }
};dfs(dfs, 1);

for (int i = 0;i < n;i ++){
    cout << f[end[i]] << "\n";
}//输出t[i]在s中出现的次数
```

### 后缀数组

```c++
struct SuffixArray {
    int n;
    vector<int> sa, rk, lc;
    SuffixArray(const string &s) {
        n = s.length();
        sa.resize(n);
        lc.resize(n - 1);
        rk.resize(n);
        iota(sa.begin(), sa.end(), 0);
        sort(sa.begin(), sa.end(), [&](int a, int b) {return s[a] < s[b];});
        rk[sa[0]] = 0;
        for (int i = 1; i < n; ++i)
            rk[sa[i]] = rk[sa[i - 1]] + (s[sa[i]] != s[sa[i - 1]]);
        int k = 1;
        vector<int> tmp, cnt(n);
        tmp.reserve(n);
        while (rk[sa[n - 1]] < n - 1) {
            tmp.clear();
            for (int i = 0; i < k; ++i)
                tmp.push_back(n - k + i);
            for (auto i : sa)
                if (i >= k)
                    tmp.push_back(i - k);
            fill(cnt.begin(), cnt.end(), 0);
            for (int i = 0; i < n; ++i)
                ++cnt[rk[i]];
            for (int i = 1; i < n; ++i)
                cnt[i] += cnt[i - 1];
            for (int i = n - 1; i >= 0; --i)
                sa[--cnt[rk[tmp[i]]]] = tmp[i];
            swap(rk, tmp);
            rk[sa[0]] = 0;
            for (int i = 1; i < n; ++i)
                rk[sa[i]] = rk[sa[i - 1]] + (tmp[sa[i - 1]] < tmp[sa[i]] || sa[i - 1] + k == n || tmp[sa[i - 1] + k] < tmp[sa[i] + k]);
            k *= 2;
        }
        for (int i = 0, j = 0; i < n; ++i) {
            if (rk[i] == 0) {
                j = 0;
            } else {
                for (j -= j > 0; i + j < n && sa[rk[i] - 1] + j < n && s[i + j] == s[sa[rk[i] - 1] + j]; )
                    ++j;
                lc[rk[i] - 1] = j;
            }
        }
    }
};
```

### 后缀自动机

```c++
struct SAM {
    static constexpr int ALPHABET_SIZE = 26;
    struct Node {
        int len;
        int link;
        array<int, ALPHABET_SIZE> next;
        Node() : len{}, link{}, next{} {}
    };
    vector<Node> t;
    SAM() {
        init();
    }
    void init() {
        t.assign(2, Node());
        t[0].next.fill(1);
        t[0].len = -1;
    }
    int newNode() {
        t.emplace_back();
        return t.size() - 1;
    }
    int extend(int p, int c) {
        if (t[p].next[c]) {
            int q = t[p].next[c];
            if (t[q].len == t[p].len + 1) {
                return q;
            }
            int r = newNode();
            t[r].len = t[p].len + 1;
            t[r].link = t[q].link;
            t[r].next = t[q].next;
            t[q].link = r;
            while (t[p].next[c] == q) {
                t[p].next[c] = r;
                p = t[p].link;
            }
            return r;
        }
        int cur = newNode();
        t[cur].len = t[p].len + 1;
        while (!t[p].next[c]) {
            t[p].next[c] = cur;
            p = t[p].link;
        }
        t[cur].link = extend(p, c);
        return cur;
    }
    int extend(int p, char c, char offset = 'a') {
        return extend(p, c - offset);
    }
    
    int next(int p, int x) {
        return t[p].next[x];
    }
    
    int next(int p, char c, char offset = 'a') {
        return next(p, c - 'a');
    }
    
    int link(int p) {
        return t[p].link;
    }
    
    int len(int p) {
        return t[p].len;
    }
    
    int size() {
        return t.size();
    }
};
    string s;
    cin >> s;
    
    SAM sam;
    int p = 1;
    for (auto c : s){
        p = sam.extend(p, c);
    }

    vector<int>cnt(sam.size());
    vector<vector<int>>adj(sam.size());
    
    p = 1;
    for (auto c : s){
        p = sam.next(p, c);
        cnt[p] ++;
    }

    for (int i = 2; i < sam.size(); i++) {
        adj[sam.link(i)].push_back(i);
    }

    auto dfs = [&](auto self, int u) -> void{
        for (auto v : adj[u]){
            self(self, v);
            cnt[u] += cnt[v];
        }
    };dfs(dfs, 1);

    i64 ans = 0;
    for (int i = 2;i < sam.size();i ++){
        if (cnt[i] > 1){
            ans = max(ans, 1LL * cnt[i] * sam.len(i));
        }
    }
    cout << ans << "\n";// 求出 S的所有出现次数不为 1 的子串的出现次数乘上该子串长度的最大值。
    
```

### Manacher

```c++
struct Manacher{
    string s;
    int len, mr, C;
    vector<int>d;
    void pre(string &_s){
        s = "#";
        for (auto k : _s){
            s += k;
            s += '#';
        }
        len = s.length();
        d.resize(len, 0);
        for (int i = 0, l = 0, r = -1; i < len; i++) {
            int k = (i > r) ? 1 : min(d[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < len && s[i - k] == s[i + k]) {
                k++;
            }
            d[i] = k--;
            if (i + k > r) {
                l = i - k;
                r = i + k;
            }
        }
    }
    i64 palic(){//回文串计数
        i64 res = 0;
        for (int i = 1;i <= len - 2;i ++){
            res += (d[i] + 1 + (i & 1)) / 2;
        }
        return res;
    }
};// d[i]为最长回文半径， 最长回文长度为max(d[i] - 1);
```



## 8.杂类

### 三分

```c++
int l = 0, r = n;
while (r - l > 3){
    int m1 = l + (r - l) / 3;
    int m2 = r - (r - l) / 3;
    if (check(m1) <= check(m2)){
        r = m2;
    }else{
		l = m1;
    }
}
int minv = check(l);
for (int i = l + 1;i <= r;i ++){
    minv = min(minv, check(i));
}//  求最小

int l = 0, r = n;
while (r - l > 3){
    int m1 = l + (r - l) / 3;
    int m2 = r - (r - l) / 3;
    if (check(m1) <= check(m2)){
		l = m1;
    }else{
		r = m2;
    }
}
int maxn = check(l);
for (int i = l + 1;i <= r;i ++){
    maxn = min(maxn, check(i));
}//  求最大


```

### int128输入输出

```c++
istream &operator>> (istream &is, i128 &n){
	string s;
	is >> s;
 
	n = 0;
	for (auto c : s){
		if (c >= '0' and c <= '9'){
			if (c >= '0' and c <= '9'){
				n = n * 10 + (c - '0');
			}
		}
	}
	return is;
}
 
ostream &operator <<(ostream &os, i128 n){
	string s;
	if (n == 0){
		s = "0";
		return os << s;
	}
	while (n){
		s += '0' + n % 10;
		n /= 10;
	}
	reverse(s.begin(), s.end());
	return os << s;
}
```

### 对拍

```shell
//linux 需chmod +x test.sh给脚本添加可执行权限：
while true; do
    ./gen > 1.in
    ./naive < 1.in > std.out
    ./a < 1.in > 1.out
    if diff 1.out std.out; then
        echo ac
    else
        echo wa
        break
    fi
done

./test.sh

//windows
while true; do
    ./gen.exe > 1.in
    ./naive.exe < 1.in > std.out
    ./a.exe < 1.in > 1.out
    if diff 1.out std.out; then
        echo ac
    else
        echo wa
        break
    fi
done

bash test.sh
```

